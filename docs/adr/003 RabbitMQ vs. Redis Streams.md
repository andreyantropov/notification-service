# ADR 003: Выбор Message Queue для сервиса уведомлений

**Дата:** 2025-10-21
**Участники:**

- Антропов Андрей (Руководитель отдела разработки)
- Гончар Артем (Fullstack-Разработчик)
- Лущиков Всеволод (DevOps)

## Статус

Принято  
_2025-10-21_

## Контекст

В текущей архитектуре сервис уведомлений использует in-memory буфер для временного хранения сообщений перед отправкой. Такой подход не обеспечивает отказоустойчивость, не поддерживает retry-механизмы и dead-letter queues (DLQ), а также не позволяет реализовать stateless-архитектуру.

Необходимо выбрать Message Queue (MQ) для надёжной и масштабируемой обработки уведомлений с поддержкой:

- Повторных попыток доставки (retry)
- Dead-letter queue для обработки неудачных сообщений
- Гарантированной доставки
- Возможности перехода к stateless-обработке

Рассматривались два варианта: **RabbitMQ** и **Redis Streams**.

## Варианты решения

### 1. RabbitMQ

**✅ Преимущества:**

- Встроенная поддержка retry-механизмов через TTL и alternate exchange.
- Нативная реализация dead-letter queue (DLQ).
- Зрелая, стабильная и широко используемая технология.
- Поддержка различных режимов подтверждения доставки (ack/nack).
- Богатая экосистема инструментов мониторинга и управления.
- Хорошо документирован, понятен команде.

**❌ Недостатки:**

- Отправка и обработка сообщений осуществляется по одному (без нативной поддержки batch-чтения/записи).
- Требует дополнительной настройки для высокой пропускной способности.
- Больший overhead по сравнению с Redis в сценариях с высокой частотой обмена.

### 2. Redis Streams

**✅ Преимущества:**

- Поддержка batch-операций (чтение и запись пачками).
- Высокая производительность и низкая задержка.

**❌ Недостатки:**

- Отсутствие встроенных механизмов retry и DLQ — требуется реализация в приложении.
- Более сложная логика обработки ошибок и повторных попыток.
- Меньшая зрелость в качестве MQ по сравнению с RabbitMQ.
- Ограниченные возможности мониторинга и управления очередями.

## Решение

**Выбранный вариант:** **RabbitMQ**

**Причина выбора:**  
Несмотря на отсутствие нативной поддержки batch-операций, RabbitMQ предоставляет готовые, проверенные и надёжные механизмы для retry и DLQ, что критически важно для сервиса уведомлений. Это позволяет:

- Сократить объём кастомной логики в коде.
- Повысить надёжность обработки ошибок.
- Упростить эксплуатацию и диагностику проблем.
- Обеспечить соответствие требованиям отказоустойчивости и гарантии доставки.

Поддержка stateless-обработки достигается за счёт внешнего хранения состояния в RabbitMQ, а не в памяти приложения.

## Последствия

### Положительные

- Повышение надёжности и отказоустойчивости сервиса уведомлений.
- Упрощение логики обработки ошибок и повторных попыток.
- Снижение рисков потери сообщений при сбоях.
- Возможность горизонтального масштабирования consumer'ов.
- Улучшенная наблюдаемость через встроенные инструменты RabbitMQ.

### Отрицательные

- Необходимость обрабатывать сообщения по одному, что может снизить пропускную способность при высокой нагрузке.
- Собственная реализация batching'а.
- Дополнительные усилия по настройке и мониторингу RabbitMQ-кластера.

## Риски и меры их смягчения

| Риск                                                           | Вероятность | Влияние | Меры по смягчению                                                                     |
| -------------------------------------------------------------- | ----------- | ------- | ------------------------------------------------------------------------------------- |
| Низкая пропускная способность из-за отсутствия batch-обработки | Низкая      | Низкое  | Оптимизация consumer'ов, параллельная обработка, настройка prefetch count             |
| Сложность настройки retry/DLQ                                  | Низкая      | Низкое  | Использование стандартных паттернов RabbitMQ, документирование конфигурации           |
| Дополнительная нагрузка на инфраструктуру                      | Средняя     | Среднее | Мониторинг ресурсов, автоматическое масштабирование, резервирование                   |
| Ошибки в маршрутизации сообщений                               | Низкая      | Высокое | Тестирование топологии, использование schema validation, логирование ключевых событий |

## Дополнительные материалы

- [RabbitMQ — Retry and DLQ Patterns](https://www.rabbitmq.com/dlx.html)
- [Redis Streams as a Message Queue](https://redis.io/topics/streams-intro)
- [Comparison: RabbitMQ vs Redis for Messaging](https://www.cloudkarafka.com/blog/2020-03-23-rabbitmq-vs-redis-as-a-message-broker.html)
