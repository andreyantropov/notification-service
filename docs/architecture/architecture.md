# Архитектура проекта

## Цель проекта

Сервис предназначен для транзакционной рассылки уведомлений пользователям через Bitrix24 API или Email.  
Логирование выполнено в InfluxDB для дальнейшего мониторинга через Grafana.

## Структура проекта

```src/
├── api/ # API
│ └── controllers/ # Контроллеры
│ └── docs/ # Документация Swagger
│ └── dtos/ # ZOD-схемы
│ └── fabrics/ # Фабрики
│ └── middleware/ # Moddleware
│ └── routes/ # Маршруты
├── application/ # Прикладной уровень: бизнес-логика
│ └── services/
│   ├── notificationDeliveryService/ # Сервис уведомлений
│   └── notificationLoggerService/ # Логгер
│ └── useCases/ # UseCase'ы
├── domain/ # Доменная модель
│ └── interfaces/ # Абстракции (порты)
│  ├── Notification.ts
│  ├── NotificationSender.ts
│ └── types/ # Пользовательские типы
│  └── Recipient.ts
├── infrastructure/ # Инфраструктурные клиенты
│ └── senders/ # Каналы рассылки уведомлений
│   ├── bitrixSender/
│   └── smtpSender/
│ └── fabrics/ # Фабрики
├── shared/ # Общие абстракции и утилиты
│ └── infrastructure/
│  └── loggers # Логгеры
│  └── fabrics
│ └── interfaces/
│  ├── Log.ts
│  └── Logger.ts
│ └── utils/
│  ├── retry.ts
│  └── toSnakeCase.ts
├── configs/ # Конфиги инфраструктурных сущностей
├── containers/ # DI-контейнеры для сбора зависимостей
├── bootstrap/ # Запуск приложения
└── index.ts # Точка входа приложения/Composition Root
```

## Архитектурные принципы

Проект разработан с соблюдением следующих архитектурных подходов:

- **Clean Architecture**: уровни `domain`, `application`, `api` и `infrastructure` чётко разделены. Бизнес-логика изолирована от технических деталей реализации.
- **KISS (Keep It Simple, Stupid)**: решения принимаются с учётом простоты. Сложные абстракции добавляются только когда они действительно нужны.
- **DRY (Don't Repeat Yourself)**: повторяющаяся логика выносится в отдельные модули (например, `fallbackSender`) для переиспользования.
- **Частичное применение SOLID**:
  - **SRP (Single Responsibility Principle)**: каждый модуль решает одну задачу
  - **OCP (Open/Closed Principle)**: система открыта для расширения, но закрыта для изменения
  - **DIP (Dependency Inversion Principle)**: зависимости внедряются через интерфейсы (например, `NotificationSender`)
  - **ISP (Interface Segregation Principle)**: интерфейсы содержат только необходимые методы, например, `Recipients` содержит только те поля, которые могут быть у клиента
- **Функциональный стиль**: сервисы реализованы в функциональной парадигме — используются **чистые функции**, **явные зависимости**, **минимизация состояния**
- **Тестируемость**: сервисы легко тестировать благодаря явным зависимостям и функциональной организации кода
- **Масштабируемость**: новые способы доставки, источники данных и стратегии отправки можно добавлять без изменения существующего кода
- **Fail Fast**: ошибки проверяются на этапе создания клиента, чтобы минимизировать риски во время выполнения
- **Fallback Pattern**: логгирование и доставка уведомлений пробуют несколько способов, прежде чем считать операцию неудачной

## API сервиса

### Эндпоинт `POST /notifications`

Эндпоинт принимает HTTP POST запросы с данными уведомления.

#### Заголовки:

- `Content-Type: application/json`

#### Тело запроса:

```json
{
  "recipients": [
    {
      "type": "bitrix",
      "value": "12345"
    },
    {
      "type": "email",
      "value": "user@example.com"
    }
  ],
  "message": "Текст уведомления"
}
```

#### Варианты ответа:

- `201 Created`: Уведомление успешно обработано
- `400 Bad Request`: Ошибка валидации (например, неверный формат email или отсутствие обязательных полей)
- `404 Not Found`: Запрашиваемый ресурс не найден
- `429 Too Many Requests`: Превышен лимит запросов (rate limit)
- `500 Internal Server Error`: Внутренняя ошибка сервера

#### Документация:

Полная спецификация доступна по адресу `/docs` в формате Swagger UI.

#### Реализованные middleware:

Все входящие запросы проходят через следующие обработчики на уровне middleware:

1. **Логгирование всех запросов** — фиксируются метаданные запроса для последующего анализа.
2. **Проверка rate limit** — ограничение количества запросов от одного клиента во избежание перегрузки сервиса.
3. **Перехват ошибки 404** — если запрашиваемый эндпоинт не найден, клиент получает корректный HTTP-ответ.
4. **Перехват ошибки 500** — глобальный обработчик неожиданных исключений, предотвращающий падение сервиса.
5. **Проверка тела request** — валидация JSON и структуры данных перед дальнейшей обработкой.

## Стратегия доставки уведомлений

1. **Количество попыток**:
   - На каждый канал: 1 попытка (можно увеличить с помощью утилиты retry)
   - Если все попытки провалились → записывается лог уровня `Warning` / `Error`
2. **Порядок работы (пример)**:
   - Для каждого получателя:
     - Отправка через Bitrix24 (если указан `bitrixId`)
     - Если Bitrix24 недоступен → переходим к SMTP (если указан `email`)
     - Если оба канала упали → выбрасываем ошибку и завершаем работу

## Жизненный цикл уведомления

1. **Получение**:
   - Уведомления приходят на сервер по API через `POST /notifications`
2. **Отправка (пример)**:
   - Попытка через Bitrix24 (если указан `bitrixId`)
   - Если не удалось — через SMTP (если указан `email`)
   - В случае успеха: уведомление удаляется из БД
   - В случае ошибки: логируется и записывается в DLQ и удаляется из БД (на данный момент не реализовано)
3. **Логирование**:
   - Все этапы логируются в InfluxDB
   - При падении InfluxDB используется fallback-логгер (localFileLogger)
4. **Завершение**:
   - Выход через `process.exit(1)` при критической ошибке

## Компоненты

1. **Сервис уведомлений (NS)**
   - Описание: Сервис транзакционной рассылки уведомлений пользователям через различные каналы связи (Bitrix24, Email). Уведомления приходят на сервер по API.
   - Технологии: TypeScript + Node.js.
   - Зависимости:
     - Библиотеки: `axios`, `nodemailer`, `express`, `@influxdata/influxdb-client`, `dotenv`.
     - Инструменты разработки: `eslint`, `prettier`, `vitest`, `ts-node`, `nodemon`.
2. **Централизованное логирование (Log)**
   - Описание: Система сбора и хранения логов для мониторинга работы сервиса.
   - Технологии: InfluxDB.
   - Клиентская библиотека: `@influxdata/influxdb-client`.
3. **Каналы отправки уведомлений**
   - **Bitrix24**: Первичный канал отправки уведомлений через API Bitrix24.
     - Библиотека: `axios`.
   - **SMTP**: Резервный канал отправки уведомлений через почтовый сервер.
     - Библиотека `nodemailer`.

---

## Диаграмма компонентов

### 1. Внешняя схема

```mermaid
flowchart TB
    subgraph Docker
        Container[Контейнер notification-service]
    end
    ExternalSystem -->|HTTP POST /notifications| Container
    Container --> Bitrix[(Bitrix24 API)]
    Container --> SMTP[(SMTP сервер)]
    Container --> Log[(InfluxDB)]
    Log --> Admin
    Bitrix --> User
    SMTP --> User
```

### 2. Внетренняя схема

```mermaid
graph TD
    subgraph Domain
        INotificationSender[(INotificationSender)]
        ILoggerWriter[(ILoggerWriter)]
        Notification[Notification]
        Recipient[Recipient]
    end
    subgraph Application
        NotificationService[createNotificationService]
        NotificationLoggerClient[createApplicationLogger]
    end
    subgraph Infrastructure
        BitrixClient[bitrixClient]
        SmtpClient[smtpClient]
        InfluxDbLogger[influxDbLogger]
        LocalFileLogger[localFileLogger]
    end
    subgraph Shared
        FallbackLogger[fallbackLogger]
        Retry[retry]
    end
    NotificationLoggerClient -->|uses| ILoggerWriter
    NotificationService -->|uses| INotificationSender
    NotificationService -->|uses| NotificationLoggerClient
    BitrixClient -.->|implements| INotificationSender
    SmtpClient -.->|implements| INotificationSender
    InfluxDbLogger -.->|implements| ILoggerWriter
    LocalFileLogger -.->|implements| ILoggerWriter
    FallbackLogger -->|wraps multiple loggers| ILoggerWriter
    FallbackLogger --> InfluxDbLogger
    FallbackLogger --> LocalFileLogger
    NotificationService -->|DI через конструктор| BitrixClient
    NotificationService -->|DI через конструктор| SmtpClient
    NotificationService -->|DI через конструктор| NotificationLoggerClient
    NotificationLoggerClient -->|DI через fallback| ILoggerWriter
```

---

## Диаграмма последовательностей

```mermaid
sequenceDiagram
    participant Client as Клиент
    participant NS as Сервис уведомлений
    participant Bitrix as Bitrix24 API
    participant SMTP as SMTP сервер
    participant Log as Логирование
    participant User as Пользователь

    Client->>NS: POST /notifications

    alt Некорректное тело запроса
        NS->>Client: HTTP 400 Некорректное тело запроса
    end

    loop Для каждого получателя
        alt есть bitrixId
            NS->>Bitrix: Отправка уведомления
            alt Успех
                Bitrix-->>NS: 200 OK
                NS->>Log: INFO "Успешная отправка через Bitrix"
                NS->>Client: HTTP 201 Created
            else Ошибка
                Bitrix-->>NS: 400 Error
                NS->>Log: WARNING "Не удалось отправить уведомление черех Bitrix"
            end
        end

        alt есть email
            NS->>SMTP: Отправка уведомления
            alt Успех
                SMTP-->>NS: 200 OK
                NS->>Log: INFO "Успешная отправка через SMTP"
                NS->>Client: HTTP 201 Created
            else Ошибка
                SMTP-->>NS: 400 Error
                NS->>Log: WARNING "Не удалось отправить уведомление через SMTP"
            end
        end

        alt Не удалось отправить ни одним способом
            NS->>Log: ERROR "Не удалось отправить уведомление"
            NS->>Client: HTTP 500 Не удалось отправить уведомление
        end
    end
```

---

## Описание процесса работы системы

1. **Получение списка уведомлений**:
   - Сервис уведомлений (NS) получает уведомления от внешних систем через HTTP-запрос `POST /notifications`.
2. **Обработка уведомлений**:
   - Для каждого получателя NS проверяет наличие соответствующих полей (`bitrixId`, `email`) и отправляет уведомление всем подходящим способами.
   - При неудачной отправке через Bitrix24 (если указан `bitrixId`), NS использует резервный канал — SMTP (если указан `email`).
   - Если оба канала недоступны, записывается ошибка в логи.
3. **Ответ клиенту**:
   - После обработки всех уведомлений NS отправляет статус HTTP 201 Created.
4. **Логирование**:
   - Все действия (успешные отправки, ошибки, удаления) логируются в InfluxDB для анализа и мониторинга.

---

## Модульная организация и управление зависимостями

Система построена таким образом, чтобы быть гибкой и легко тестируемой. Для этого используется принцип внедрения зависимостей (`Dependency Injection`) и паттерн **фабрик**.

### Использование фабрик

Для инициализации внешних клиентов используются фабричные функции:

Это даёт следующие преимущества:

- **Клиенты легко заменить**
- **Минимальное количество глобальных переменных**
- **Удобство тестирования** — можно передавать мокнутые зависимости

Пример:

```ts
const sender = createDefaultSender(bitrixConfig, smtpConfig, onError);
const logger = createDefaultLogger(influxDbLoggerConfig);
const server = createDefaultApp(ServerConfig);
```

Фабрики находятся в директории `fabrics/`.

---

## Контейнеризация (Docker)

Сервис уведомлений (`notification-service`) может быть запущен в контейнеризованной среде с использованием Docker. Это позволяет унифицировать процесс запуска, изолировать зависимости и использовать один и тот же образ как в development-, так и в production-среде.

### 1. Сборка образа

Образ строится на основе официального образа `node:23.x` и включает:

- Скомпилированный TypeScript код (`dist/`)
- Установленные зависимости (`node_modules`)
- Файлы конфигурации и переменных окружения (не включаются в сам образ, но подставляются при запуске)

Пример команды сборки:

```bash
docker build -t notification-service .
```

### 2. Архитектура контейнера

Контейнер состоит из следующих компонентов:

- **Базовый образ**: `node:23.11.0`
- **Рабочая директория**: `/app`
- **Точка входа**: `npm run start` (для production)
- **Порты**: не публикуются напрямую, т.к. сервис не имеет HTTP-интерфейса
- **Переменные окружения**: передаются через файл `.env` при запуске
- **Монтирование**: не требуется в production, но используется в режиме разработки

### 3. Режимы запуска

#### Production-режим

В этом режиме запускается уже скомпилированное приложение (`dist/index.js`). Используются переменные окружения из `.env`.

```bash
docker run -d \
  --name notification-service \
  --env-file ../.env \
  -p "$PORT:$PORT" \
  notification-service
```

Также можно использовать готовый скрипт `run.sh`, который гарантирует чистый запуск.

> Контейнер использует переменные из `.env`. Убедитесь, что файл существует.

#### Development-режим

Режим разработки позволяет монтировать исходный код внутрь контейнера и отслеживать изменения без пересборки образа. Используется `npm run dev` с автоматическим перезапуском.

```bash
docker run -it --rm \
  --name notification-service-dev \
  --env-file ../.env.dev \
  -v $(pwd)/src:/app/src \
  -v $(pwd)/package.json:/app/package.json \
  -v $(pwd)/tsconfig.json:/app/tsconfig.json \
  -w /app \
  node:23.11.0 \
  npm run dev
```

### 4. Интеграция с системой

Контейнер взаимодействует со следующими внешними системами:
| Система | Тип взаимодействия | Переменная окружения |
| ----------------- | ------------------ | -------------------- |
| Bitrix24 REST API | HTTP-запросы | BITRIX\_\* |
| SMTP-сервер | Отправка email | SMTP\_\* |
| InfluxDB | Логирование метрик | INFLUXDB\_\* |

### 5. Управление контейнерами

Для управления жизненным циклом контейнера предусмотрены следующие скрипты:
| Скрипт | Назначение |
| ------------ | ------------------------------------- |
| `build.sh` | Сборка Docker-образа |
| `run.sh` | Запуск контейнера в production-режиме |
| `stop.sh` | Остановка и удаление контейнера |
| `restart.sh` | Перезапуск контейнера |
| `logs.sh` | Просмотр логов контейнера |
| `status.sh` | Запрос статуса работы контейнера |

## Метрики и мониторинг

Все события логируются в InfluxDB с такими полями:

- `measurement`: notification_service_logs
- `timestamp`: временная метка
- `tags`:
  - `level`: info, warning, error, critical
  - `currentService`: notification-service
  - `callerService`: имя сервиса, который вызвал отправку уведомлений
  - `trigger`: api, cron, manual
  - `environment`: dev, stage, prod
  - `eventType`: send_bitrix_notification, send_smtp_notification, db_query_error
  - `host`: имя хоста, с которого отправлено событие
  - `traceId`: id трейса
  - `correlationId`: id события в рамках трейса
  - `spanId`: этап, на котором произошло событие
- `fields`:
  - `id`: уникальный ID события
  - `message`: текст уведомления
  - `durationMs`: длительность операции
  - `payload`: данные уведомления
  - `error`: если была ошибка

Графики доступны через Grafana.

## Отказоустойчивость

Сервис рассчитан на работу в условиях возможных сбоев:
| Сценарий | Как обрабатывается |
| -------------------------------- | ----------------------------------- |
| Bitrix24 API недоступен | Используется резервный канал — SMTP |
| SMTP недоступен | Логируется ошибка |
| InfluxDB недоступен | Используется fallback-логгер в файл |
| Файл логов не может быть записан | Логируется в консоль |

---

## Безопасность

Сервис работает с внешними системами и чувствительными данными, поэтому реализованы следующие меры безопасности:

- **HTTPS для внешних API**: Все запросы к Bitrix24 отправляются через защищённое HTTPS-соединение.
- **Защита секретов через `.env`**: Конфиденциальные данные (SMTP-логины, вебхуки Bitrix24 и т.д.) хранятся во внешнем файле `.env`, не попадающем в репозиторий.
- **Безопасное использование SMTP**:
  - Аутентификация через TLS/SSL.
  - Хранение учетных данных — через переменные окружения.

> _Примечание_: Если система будет масштабироваться, можно рассмотреть использование Vault или других решений для управления секретами.

---

## Масштабируемость и расширяемость

### Горизонтальное масштабирование

Сервис является stateless и может быть запущен в нескольких экземплярах одновременно (например, через Docker Swarm или Kubernetes), при этом каждый экземпляр обрабатывает уникальную часть очереди уведомлений.

### Расширяемость архитектуры

- **Добавление новых каналов доставки** (Telegram, SMS и др.) осуществляется путём реализации интерфейса `NotificationSender`.
- **Модульность логгирования** позволяет легко подключать новые способы записи логов через Fallback Pattern.

### Долгосрочные возможности

- Планируемая интеграция с шиной данных (message broker) позволит перейти к более гибкой обработке уведомлений.
- Возможность добавления Web UI для управления правилами отправки и просмотра состояния очереди.

---

## Use Cases / Сценарии использования

> Описание типовых ситуаций, в которых сервис участвует как компонент системы ISPlanar.
> | № | Сценарий | Краткое описание |
> | --- | ------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
> | 1 | **Уведомление о просроченной задаче** | Сервис получает информацию о просроченной задаче, формирует уведомление и отправляет его через Bitrix24 или Email. |
> | 2 | **Изменение статуса задачи** | При изменении статуса задачи (например, "В работе" → "Выполнена") пользователь получает уведомление. |
> | 3 | **Назначение новой задачи** | После назначения задачи пользователю он получает соответствующее уведомление. |
> | 4 | **Создание проекта** | При создании нового проекта уведомление отправляется всем участникам. |
> | 5 | **Резервная отправка через Email** | Если Bitrix24 недоступен, уведомление отправляется через SMTP. |
